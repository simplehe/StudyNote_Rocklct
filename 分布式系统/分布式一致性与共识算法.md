## 一致性问题
分布式系统毫无疑问，存在一个一致性问题。即系统对外如何呈现出一致的状态，比如所有节点都达成失败也是一种一致。

### 一致性要求
规范的说，分布式系统达成一致的过程，应该满足：

 - 可终止性(termination):一致的结果在有限的时间内完成
 - 约同性(agreement) 不同的节点最终完成决策的结果是相同的
 - 合法性(validity) 决策的结果必须是某个节点提出提案。

### 共识算法
**一致性描述的是结果状态，共识则是一种手段。** 共识描述了多个节点之间，彼此达成一致结果的过程。

也就是说，共识算法是对某个提案，大家达成意见一致的过程。

理想的系统不存在，不同节点之间存在延迟，还可能故障，甚至可能存在恶意节点伪造信息。

 - **一般地，把出现故障(crash 或 fail-stop,即不响应)但不会伪造信息的情况，称为非拜占庭错误(non-byzantine fault) 或者也可以叫做故障错误(Crash Fault)**

 - **伪造信息恶意响应的情况称为拜占庭错误(Byzantine fault),对应节点为拜占庭节点**

根据解决的错误是故障错误还是拜占庭错误，共识算法可以分为两类：

1. Crash Fault Tolerance(CFT) 类算法
2. Byzantine fault Tolerance(BFT) 类算法

解决非拜占庭错误，有一些经典算法：Paxos,Raft及其变种。性能较好，处理较快，但是容忍不超过一半的节点故障。

对于拜占庭容错，有PBFT(Practical Byzantine fault Tolerance)为代表的确定性算法，还有PoW为代表的概率算法。**对于确定性算法，达成共识就不可逆转**，对于 **概率性算法，共识结果只是临时的，可能被推翻**。 拜占庭容错算法，性能较差，容忍不超过三分之一的节点故障。

#### CAP
见CAP原理笔记

#### ACID原则
参见数据库事务笔记。分布式数据库一样遵循ACID原则。

#### Paxos算法
Paxos问题，就是指分布式系统中存在故障，但不存在恶意节点的场景。

Paxos算法1990年被Lamport提出，广泛采用在zookeeper，chubby等分布式系统中。是第一个被广泛应用的共识算法。

算法基本原理，将节点逻辑上分为三种角色(同一节点可以担任多个角色):
 - 提案者(proposer)
 - 接受者(acceptor)
 - 学习者(learner)

 提案者提出一个提案，接受者们负责对这个提案投票，学习者不参与投票过程，只参与传播结果。

基本过程就是多个提案者争取到提案的权利(得到大多数接受者的支持)，得到提案权的提案者放松提案给所有人进行确认，得到大部分人确认的提案成为标准答案。

 - 单提案者，多接受者：提案只有一个，只有通过和失败两种状态，极易达成一致。但是一旦提案者故障，系统无法工作，中心化。

 - 多个提案者，单个接受者：共识也很容易达成。接受者只需要接受第一个拿到的提案作为决议即可。单点故障依旧会引起系统无法工作。

 - 多个提案者，多个接受者：一种情况是按时间分片，某一个时间段内只有一个提案者，则退化到单提案者情况。但需要设计一种机制保证提案者按某种特定序列(如根据时间，猜拳)产生。这种设计很难。第二种情况是为提案分配递增id，接受者拿到提案后取id大的(或者根据某种排序原则来取id)。过程涉及到 **两阶段提交**。

##### 两阶段提交
Paxos提交分为两个阶段，准备(prepare)和提交(commit),准备阶段通过锁来解决对哪个提案的内容进行确认，提交阶段解决大多数确认最终值的问题。

 - 准备阶段：接受者时刻保留收到的最大提案编号，有新的编号过来比保留编号大，则更新最大编号，并重新返回提案值，比保留编号小的提案则舍弃不处理。
 - 提交阶段：提案者收到大多数的提案支持。则可准备发出带有刚才提案号的消息，如果收到的回复没有提案号，说明锁定成功，使用自己的提案，如果收到的回复有更大提案编号，则替换自己的提案值。接受者收到 **接受消息** 以后，发现提案号不小于自己的保留最大提案号，则接受这个提案，并更新最大接受消息。

 一旦大多数接受者接受了共同的提案值，则形成决议，成为最终确认。
