## 分页实现
分页是开发中最常见的需求之一。
对于分页，我们讨论的最多的是后端的数据库分页，这关乎到我们应用程序的性能，也是分页这个需求的核心。
而前端要做的，是把后端返回的数据呈现在页面上，工作被认为是简单琐碎的。

### 上下页的实现
如果单纯只考虑前端展示上一页下一页，后端则需维护两个字段：

```
// 后端返回数据结构
// GET /items?page=5
{
    // hasPrev 和 hasNext 都需要后端去查询总数，然后计算出来
    hasPrev: true,
    hasNext: true,
    items: [...]
}
```

后端必须向数据库拿到数据的总是count，然后根据客户端请求过来的count来计算，当前page是否还有下一页或者上一页。然后封装成布尔值hasPrev和hasNext返回给客户端。

### 前端计算
计算hasPrev和hasNext这个部分可以放到前端来完成，也就是所谓的前端分页。这种情况，**后端只需要提供数据总数就可以了**。但是，也要考虑到前端数据丢失的处理方案。

通用流程如下：

 - 第一次加载页面时需要调用一次查询总数的接口，同时调用获取元素的接口
 - 返回数据后计算 hasPrev 和 hasNext，用来判断是否需要显示上一页/下一页按钮
 - 移除容器内的所有元素，再插入新的元素（即用新元素替换旧元素）

### 页码
生成页码，当然是不可能把所有页的数字都显示出来，中间多出来的可以用省略号来代替。

比如下面的方案，返回列表，-1则用省略号渲染。

```
// ------------------------------
// 我个人比较喜欢用 -1 来表示省略的区域
// 在生成 DOM 的时候，可以用省略号来展示
// ------------------------------
// 假设当前是第 1 页
[1, 2, 3, -1, 50]
// 假设当前是第 3 页
[1, 2, 3, 4, 5, -1, 50]
// 假设当前是第 25 页
[1, -1, 23, 24, 25, 26, 27, -1, 50]
// 假设当前是第 48 页
[1, -1, 46, 47, 48, 49, 50]
// 假设当前是第 50 页
[1, -1, 48, 49, 50]
```

生成页码的原则通常都是：

 - 第一页和最后一页必须展示
 - 其他页面按需展示，通常是当前页面的前后两页（即 x +- 2）
 - 当页数少于 10 页的时候，直接显示出所有页码（为什么是 10 页？其实在满足前两个原则的情况下，只要 7 页省略号就会正常显示了。但页数较少的情况下显示省略号感觉怪怪的。）
