# 红黑树
红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构。典型的用途是实现关联数组。它可以在`O(logn)`时间内做查找，插入和删除，这里的`n`是树中元素的数目。

红黑树的应用比较广泛，主要是用它来**存储有序的数据**
例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。

### 跟AVL树对比？
红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。

也就是说，红黑树不是严格控制左、右子树高度或节点数之差小于等于1。因此旋转的次数少


## 红黑树特性
红黑树有五个特性

1. 每个节点或者是黑色，或者是红色。

2. 根节点是黑色。

3. 每个叶子节点（NIL）是黑色。 \[注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！也就是空节点\]
4. 如果一个节点是红色的，则它的子节点必须是黑色的。

5. 从一个节点到该节点的叶子节点的所有路径上包含相同数目的黑节点。

红黑树示意图如下所示

![](image/rbt0.jpg)

且要注意，每个**叶子节点**的左右指针(空指针)指向的“NIL节点(也就是空节点)”也当做是树中的节点.且这个"空节点"一定是黑色。

**从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度**。

红黑树有一个定理：**一包含n个内部节点的红黑树的高度是O(logn)**，显然这就是红黑树高效的优势。

性质 5 是成为红黑树最主要的条件，**后序的插入、删除操作都是为了遵守这个规定**。

红黑树并不是标准平衡二叉树，它以性质 5 作为一种平衡方法，使自己的性能得到了提升。

## 红黑树的旋转
最关键的部分，当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。

为了继续保持红黑树的性质，我们可以通过对结点进行重新着色，以及对树进行相关的旋转操作

红黑树的旋转有2个基本操作，**左旋和右旋**，这跟AVL树旋转的LL和RR是类似的。

### 左旋

![](image/rbt1.jpg)

AVL树在RR触发时，也会进行左旋操作。

具体左旋代码也可以参考AVL笔记。

### 右旋
右旋跟左旋类似，不再赘述。

![](image/rbt2.jpg)

对于树的旋转，能保持不变的只有原树的搜索性质，而原树的红黑性质则不能保持，在红黑树的数据插入和删除后可利用旋转和颜色重涂来恢复树的红黑性质。

## 红黑树的插入
红黑树的插入，跟普通二叉查找树的插入并无二样。

很显然，在插入节点的过程中，红黑树的性质将会被打破，我们必须遵守一些规则，来调整树使得树能保持红黑树的结构。

下面我们就来讨论，插入的步骤。

### 1. 将红黑树当作一颗二叉查找树，将节点插入。
这个无需多说， 红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。无论染色还是旋转，都不会改变**二叉查找树**这个性质的。

### 2.将插入的节点着色为"红色"
为什么着色成红色，而不是黑色呢？

回顾一下红黑树的5性质，我们很容易就能想到，刚插入的节点必然是叶节点(但不是空节点)，空节点必定为黑色，那么为了保持性质，节点染成红色是最好的了，这样甚至不会违背第五条性质，也就是到每个叶子节点的路径都经过相同数量的黑色节点。

少违背一条性质，后面就更好处理，所以染成红色。

### 3.旋转和染色(修复操作)
上一步骤2中，我们把插入的节点染成了红色，着满足了5大性质中的核心第五性质，叶节点路径黑节点相同。那么其他五个性质呢？

回顾五个性质，显然前三条性质是**直接满足条件**的，不需要理这三个。那么关键的就是如何调整树来满足第四性质了，也就是**红节点的子节点必须是黑色**。

我们可以分类讨论，旋转染色的几种情况。可以把红黑树的调整称之为**修复操作**，在讲到修复操作之前，我们先排除2种特例。

1. **添加根节点**，插入第一个节点的时候，显然不是染成红色，而是直接染黑，这也算一种特殊情况。

2. **父节点是黑色**，如果插入的节点，父节点是黑色，那刚好，**性质4没被破坏**，红黑树的五大性质全部保持住了，可喜可贺，**什么操作都不需要做**。


所以，**修复操作的前提就是，插入节点后的父节点是红色的**。如果是黑色，我们就可以完全不考虑了。

在父节点是红色的前提下，我们修复操作有3种情况需要考虑，我们来考虑这三种情况。

#### Case1.父亲节点和叔叔节点都是红色

![](image/rbt0.png)

假设插入的是节点 N，N打破了红黑树性质，对N进行**修复操作**

这时父亲节点 P 和叔叔节点 U 都是红色，爷爷节点 G 一定是黑色(因为红节点的父节点只能是黑色,而至少又存在根节点这一个黑色节点)。

遇到这种情况，我们**只需要颜色反转**，使**父节点和叔节点**染色成黑色，祖父节点染色成红色。转换成下图

![](image/rbt1.png)


**但是这样并没有结束**，可想而知，红色节点7此时又打破了红黑树性质，其父节点肯定是红色的，所以此时需要对旧节点G(即标号为7的节点,新节点N)再进行**修复操作**，如此传递下去。

此时的**新节点N-原来的G** 虽然要进行修复操作，但显然已经不是Case1的情况了，所以这时肯定是用别的case修复。**简而言之就是这种Case1情况下，颜色反转，然后修复操作传递给祖父节点**。

#### Case2父结点是红色,叔叔结点是黑色，当前结点是其父结点的右子

就像刚才Case1的情况转换后，就变成了这种Case2的情况。还是下图

![](image/rbt1.png)

插入节点N的父节点(标号2)也是红色，且节点7是节点2的右节点。此时需要用到旋转。

对策：以父节点为支点左旋。

![](image/rbt2.png)

如图，旋转成上图所示，这就又发生情况改变了，且此时转换为了最后一种情况case3.同时注意此时把修复操作传递给了节点2，即修复操作传递给了**原来节点的父节点**。这时候对节点2继续进行修复操作就到了case3。

#### Case3父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子

![](image/rbt2.png)

解法：父结点变为黑色，祖父结点变为红色，**在祖父结点为支点右旋**

![](image/rbt3.png)

以case3为终点，如此一来，红黑树的插入就完成了。

#### 总结
3种case的修复操作总结起来便是

1. 父节点和叔节点都是红色，则父叔节点和祖父节点进行颜色反转，修复操作传递给祖父节点。

2. 父节点是红色，叔节点是黑色，且修复节点是右节点。以父节点为支点左旋。修复操作传递给父节点

3. 父节点是红色，叔节点是红色，修复节点是左节点。以祖父节点为支点，右旋。父节点染黑色，祖父节点染红色。流程结束。


## 红黑树的删除
将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树**当作一颗二叉查找树**，将该节点从二叉查找树中删除；然后，通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：

### 1.将红黑树当作一颗二叉查找树，将节点删除。
常规流程想必都很清楚。

这和"删除常规二叉查找树中删除节点的方法是一样的"。分3种情况：
1. 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。
2. 被删除节点只有一个儿子(一个子树)。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。
3. 被删除节点有两个儿子。那么就找到左边最大的节点(假如左子树是大于原节点)，或者右子树最小的节点，替换被删除节点。然后传递删除操作，删除之前被挪上来的节点。

### 2.通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。

因为"第一步"中删除节点之后，可能会违背红黑树的特性。所以需要通过"旋转和重新着色"来修正该树，使之重新成为一棵红黑树。

在第一步中"将红黑树当作一颗二叉查找树，将节点删除"后，可能违反"特性(2)、(4)、(5)"三个特性。第二步需要解决上面的三个问题，进而保持红黑树的全部特性。


如果当前待删除节点是红色的，它被删除之后对当前树的特性不会造成任何破坏影响。
而如果被删除的节点是黑色的，这就需要进行进一步的调整来保证后续的树结构满足要求。

这里研究的是删除黑色节点的情况。

#### 分类讨论

分类情况的分析思路便是，我们设删除节点的颜色为X，替换节点的颜色为Y,那么删除节点的时候，我们X+Y分类讨论。也可以看作是我们假设替换上来的节点(即被删节点的左最大或者右最小)吸收了原来被删除节点的颜色。

假如被删的节点颜色是黑,替换上来的节点颜色是红。那么我们可以把这种情况称作是黑+红。前面是原节点颜色，后面是替换节点的颜色。

##### a.红+黑(原节点红,新节点黑)
直接把x设为黑色，结束。此时红黑树性质全部恢复。

##### b.黑加黑且节点是根
什么都不做，结束。此时红黑树性质全部恢复。

##### c.黑加黑且节点不是根

![](image/rbt5.jpg)

根据上表步骤可以重新调整红黑树。
